// +build ignore

package main

import (
	"bytes"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
	"text/template"
	"time"
)

var statuses = []int{
	http.StatusBadRequest,
	http.StatusUnauthorized,
	http.StatusPaymentRequired,
	http.StatusForbidden,
	http.StatusNotFound,
	http.StatusMethodNotAllowed,
	http.StatusNotAcceptable,
	http.StatusProxyAuthRequired,
	http.StatusRequestTimeout,
	http.StatusConflict,
	http.StatusGone,
	http.StatusLengthRequired,
	http.StatusPreconditionFailed,
	http.StatusRequestEntityTooLarge,
	http.StatusRequestURITooLong,
	http.StatusUnsupportedMediaType,
	http.StatusRequestedRangeNotSatisfiable,
	http.StatusExpectationFailed,
	http.StatusTeapot,
	http.StatusUnprocessableEntity,
	http.StatusLocked,
	http.StatusFailedDependency,
	http.StatusUpgradeRequired,
	http.StatusPreconditionRequired,
	http.StatusTooManyRequests,
	http.StatusRequestHeaderFieldsTooLarge,
	http.StatusUnavailableForLegalReasons,

	http.StatusInternalServerError,
	http.StatusNotImplemented,
	http.StatusBadGateway,
	http.StatusServiceUnavailable,
	http.StatusGatewayTimeout,
	http.StatusHTTPVersionNotSupported,
	http.StatusVariantAlsoNegotiates,
	http.StatusInsufficientStorage,
	http.StatusLoopDetected,
	http.StatusNotExtended,
	http.StatusNetworkAuthenticationRequired,
}

type Definition struct {
	Name    string
	Code    string
	Message string
}

func main() {
	var definitions []Definition

	for _, status := range statuses {
		text := http.StatusText(status)

		var nameParts []string
		var codeParts []string
		var messageParts []string

		for i, f := range strings.Fields(strings.Replace(text, "'", "", -1)) { // http.StatusTeapot
			nameParts = append(nameParts, strings.Title(f))
			if i == 0 {
				codeParts = append(codeParts, strings.ToLower(f))
				messageParts = append(messageParts, strings.Title(f))
			} else {
				codeParts = append(codeParts, strings.Title(f))
				switch f {
				case "URI":
					messageParts = append(messageParts, f)
				default:
					messageParts = append(messageParts, strings.ToLower(f))
				}
			}
		}

		name := strings.Join(nameParts, "")
		code := strings.Join(codeParts, "")
		message := strings.Join(messageParts, " ")

		switch status {
		case http.StatusTeapot:
			name = "Teapot"
		case http.StatusProxyAuthRequired:
			name = "ProxyAuthRequired"
		}

		definitions = append(definitions, Definition{
			Name:    name,
			Code:    code,
			Message: message,
		})
	}

	buf := &bytes.Buffer{}

	if err := packageTemplate.Execute(buf, struct {
		Timestamp   time.Time
		Definitions []Definition
	}{
		Timestamp:   time.Now(),
		Definitions: definitions,
	}); err != nil {
		log.Fatal(err)
	}

	dst, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("%s", buf.Bytes())
		log.Fatal(err)
	}

	if err := ioutil.WriteFile("http_errors.go", dst, 0600); err != nil {
		log.Fatal(err)
	}
}

var packageTemplate = template.Must(template.New("").Parse(`
package jsonerror

// Code generated by go generate. DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}

import "net/http"

{{- range .Definitions }}
var {{ .Name }}Response = Response{
	Error: Error{
		Code:    {{ printf "%q" .Code }},
		Message: {{ printf "%q" .Message }},
	},
}

func New{{ .Name }}Response(message string) Response {
	return Response{
		Error: Error{
			Code:    {{ printf "%q" .Code }},
			Message: message,
		},
	}
}

func (ew Writer) Write{{ .Name }}(w http.ResponseWriter, r *http.Request) {
	ew.write(w, r, http.Status{{ .Name }}, {{ .Name }}Response, nil)
}

func (ew Writer) Write{{ .Name }}Err(w http.ResponseWriter, r *http.Request, err error) {
	status := http.Status{{ .Name }}
	resp := {{ .Name }}Response.WithErr(err)
	ew.write(w, r, status, resp, err)
}
{{- end }}
`))
